/*
问题描述
　　小蓝站在一个 n 行 m 列的方格图中间，方格图的每一个方格上都标有一个正整数。
　　如果两个相邻方格（上下左右四个方向相邻）内的数的最大公约数大于 1 ，则可以从其中一个方格移动到另一个方格，当然也可以从另一个方格移回第一个方格。
　　假设小蓝开始时站在第 r 行第 c 列，请问小蓝可以移动到方格图内的多少个方格？
输入格式
　　输入的第一行包含两个整数 n, m ，用一个空格分隔，表示方格图的行数和列数。
　　接下来 n 行，每行包含 m 个正整数，相邻整数间用一个空格分隔，依次表示方格图中从第 1 行到第 n 行，每行从第 1 列到第 m 列中的数。
　　接下来一行包含两个整数 r, c，用一个空格分隔，表示小蓝所在的行号和列号。
输出格式
　　输出一行包含一个整数，表示答案。
样例输入
3 4
3 6 5 5
2 4 3 5
7 8 3 8
3 2
样例输出
5
评测用例规模与约定
　　对于50%的评测用例，1 <= n, m <= 100，方格图中的每个数不超过 10**5 （10的5次方）。
　　对于所有评测用例，1 <= n, m <= 1000，方格图中的每个数不超过 10**9 （10的9次方）。
*/

#include <iostream>
using namespace std;
int n[1001][1001];//方格图矩阵
int vist[1001][1001] = {0};//访问点矩阵，映射到方格图对应位置表示是否呗访问过
int x, y;  // 最大矩阵限制
int v = 0; // 可达点数

int gys(int a, int b)//计算最大公约数
{
    int t, max = 0;
    if (a > b)
    {
        t = a;
        a = b;
        b = t;
    }
    for (int i = 1; i <= a; i++)
    {
        if ((a % i == 0) && (b % i == 0))
        {
            if (max < i)
                max = i;
        }
    }
    // printf("%d,%d,%d\n", max, a, b);
    return max;
}

void keda(int r, int c)//访问方格点
{
    // printf("[%d,%d]:[%d]:%d\n", r, c,n[r][c],vist[r][c]);//测试输出位置，访问点
    if ((r >= 1 && r <= x) && (c >= 1 && c <= y))
    { // 判断位置合法性
        vist[r][c] = 1;
        v++;
        // 右
        if (vist[r][c + 1] == 0) // 判断是否访问过,若否则尝试访问
        {
            if ((gys(n[r][c], n[r][c + 1])) > 1) // 公约数>1就走
                keda(r, c + 1);
        }
        // 左
        if (vist[r][c - 1] == 0) // 判断是否访问过,若否则尝试访问
        {
            if ((gys(n[r][c], n[r][c - 1])) > 1) // 公约数>1就走
                keda(r, c - 1);
        }
        // 下
        if (vist[r - 1][c] == 0) // 判断是否访问过,若否则尝试访问
        {
            if ((gys(n[r][c], n[r - 1][c])) > 1) // 公约数>1就走
                keda(r - 1, c);
        }
        // 上
        if (vist[r + 1][c] == 0) // 判断是否访问过,若否则尝试访问
        {
            if ((gys(n[r][c], n[r + 1][c])) > 1) // 公约数>1就走
                keda(r + 1, c);
            
        }
    }
}

int main()
{
    int r, c;
    cin >> x >> y; // 行列数
    for (int i = 1; i <= x; i++)
    {
        for (int j = 1; j <= y; j++)
        {
            cin >> n[i][j]; // 输入阵列数字
        }
    }
    cin >> r >> c; // 位置

    /* 输出访问矩阵
    for (int i = 1; i <= x; i++)
    {
        for (int j = 1; j <= y; j++)
        {
            cout << vist[i][j]; // 输入阵列数字
        }
        cout << endl;
    }
    */
    keda(r, c);
    cout << "可达点数：" << v << endl;

    /*输出访问矩阵
    for (int i = 1; i <= x; i++)
    {
        for (int j = 1; j <= y; j++)
        {
            cout << vist[i][j]; // 输入阵列数字
        }
        cout << endl;
    }
    */
    return 0;
}