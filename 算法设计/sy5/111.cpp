/*
①数塔问题；
【题目描述】
从数塔顶层出发，每个结点可以选择向左走或向右走，要求一直走到塔底，使得走过的路径上的数值和最小。
例如对于下面这样的数塔
    1
  2   3
4   5   6
按照 1 - 2 - 4 的路线走，可取得路径上的数值和的最小值为 7。
【输入格式】
每组输入的第一个行表示行数，最大不超过 1000 行。
后面每行为这个数塔特定行包含的正整数。这些正整数不大于 10000。
【输出格式】
对于每组测试数据，输出一行答案。
【输入示例】
3
1
2 3
4 5 6
【输出示例】
7
*/
#include <stdio.h>
#include <algorithm>
using namespace std;//这里以顺序遍历为例
int num[1005][1005];//用于储存数塔每个位置的数字
int dp[1005][1005];//用于储存经过数塔每个位置所能达28到的最大和
int main()
{
    int r;
    scanf("%d",&r);//输入数塔行数
    for(int i=1;i<=r;i++)
        for(int j=1;j<=i;j++)
            scanf("%d",&num[i][j]);
    //输入数塔数据，注意i和j要从1开始，防止数组越界
    for(int i=1;i<=r;i++)//共计r行
        for(int j=1;j<=i;j++)//每行有j个数字
            dp[i][j]=max(dp[i-1][j],dp[i-1][j-1])+num[i][j];
    //经过该数字的最大和，为左上角和右上角中的max，再加上该数字
    int ans=0;
    for(int i=1;i<=r;i++)
        ans=max(ans,dp[r][i]);//从最后一行中找到最大数
    printf("%d\n",ans);//就是答案
    return 0;
}