/*采用暴力枚举的思想，通过计算前缀和的方式来求解最大子段和。
首先输入原始序列并计算前缀和，然后通过两层循环枚举所有可能的子段，
计算子段和并更新最大子段和和对应的起始和结束位置。
最后输出最大子段和的值和具体序列。
*/
// 最大子段和xz
/*
时间复杂度分析：

输入n个整数构成的序列，时间复杂度为O(n)。
计算前缀和数组s，时间复杂度为O(n)。
枚举所有可能的子段，时间复杂度为O(n^2)。
综上所述，算法的时间复杂度为O(n^2)。
空间复杂度分析：

使用了两个大小为N的数组a和s，空间复杂度为O(n)。
综上所述，算法的空间复杂度为O(n)。
*/
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 1e5 + 10;
int a[N], s[N]; // a数组存储原始序列，s数组存储前缀和

int main()
{
    int n;
    cin >> n; // 输入序列长度
    for (int i = 1; i <= n; i++)
        cin >> a[i]; // 输入原始序列

    for (int i = 1; i <= n; i++)
        s[i] = s[i - 1] + a[i]; // 计算前缀和

    int ans = -1e9, l, r; // 初始化最大子段和为负无穷，以及最大子段和的起始和结束位置

    // 枚举所有可能的子段，计算最大子段和
    for (int i = 1; i <= n; i++)
        for (int j = i; j <= n; j++)
            if (s[j] - s[i - 1] > ans)
            {
                ans = s[j] - s[i - 1];
                l = i, r = j;
            }

    // 输出最大子段和的值
    cout << ans << endl;

    // 输出最大子段和的具体序列
    for (int i = l; i <= r; i++)
        cout << a[i] << " ";

    return 0;
}
/*
算法: 最大子段和

输入: 整数数组a，数组长度n

输出: 最大子段和的值和具体序列

1. 读取输入的数组长度n和数组a
2. 计算前缀和数组s，s[i] = s[i-1] + a[i]
3. 初始化最大子段和ans为负无穷，以及最大子段和的起始和结束位置l和r
4. 对于i从1到n，对于j从i到n，计算子段和s[j]-s[i-1]，如果大于ans，则更新ans为s[j]-s[i-1]，
同时更新l和r
5. 输出最大子段和ans的值
6. 输出最大子段和的具体序列，即输出a[l]到a[r]的值
*/

