# 天天向上的力量

算法：天天向上的力量计算
输入：无
输出：不同提升和退步条件下的增长倍率和每周提升5天休息2天的倍率，以及工作日提升值

1. 初始化工作日提升值为0.01

2. 初始化年初始力量为1

3. 对于每个工作日：
   3.1 如果今天是休息日（周六或周日）：
       3.1.1 以0.99倍率退步
   3.2 否则：
       3.2.1 以1.01倍率提升
   
4. 初始化测试力量为年初力量

5. 当测试力量小于每天提升1%时，循环：
   5.1 增加工作日提升值0.01
   5.2 重置测试力量为1
   5.3 对于每个工作日：
       5.3.1 如果今天是休息日：
           5.3.1.1 以0.99倍率退步
       5.3.2 否则：
           5.3.2.1 以工作日提升值增加后的倍率提升
   
6. 输出不同条件下的增长倍率和每周提升5天休息2天的倍率，以及工作日提升值

  ```python
  import math
# 每天都提升0.1%
daysmallup = math.pow((1 + 0.001), 365)
# 每天退步0.1%
daysmalldown = math.pow((1 - 0.001), 365)
# 每天都提升0.5%
daysmall5up = math.pow((1 + 0.005), 365)
# 每天退步0.5%
daysmall5down = math.pow((1 - 0.005), 365)
# 每天都提升1%
dayup = math.pow((1 + 0.01), 365)
# 每天退步1%
daydown = math.pow((1 - 0.01), 365)

# 提升5休息2，倍率1%
power = 1  # 年初始力量
for i in range(365):
    if i % 7 in [6, 0]:
        power = power * 0.99  # 休息日退步
    else:
        power = power * 1.01  # 工作日提升

# 上五休二需要多少努力值才能等于每天提升1%
dayupdate = 0.01  # 提升值
powertest = power  # 年初始力量（测试用例）
while powertest < dayup:
    dayupdate = dayupdate + 0.01  # 工作日提升值++
    powertest = 1
    for i in range(365):
        if i % 7 in [6, 0]:
            powertest = powertest * 0.99  # 休息日退步
        else:
            powertest = powertest * (1 + dayupdate)  # 工作日提升

# 输出结果
print("每天都提升0.1%一年后是原来的{:.2f}倍，每天退步0.1%一年后只有原来的{:.2%}".format(daysmallup, daysmalldown))
print("每天都提升0.5%一年后是原来的{:.2f}倍，每天退步0.5%一年后只有原来的{:.2%}".format(daysmall5up, daysmall5down))
print("每天都提升1%一年后是原来的{:.2f}倍，每天退步1%一年后只有原来的{:.2%}".format(dayup, daydown))
print("每周提升5天休息2天，升降倍率1%一年后是原来的{:.2f}倍".format(power))
print("上五休二每个工作日需要提升{:.2%}才能等于每天提升1%的效果".format(dayupdate))
  ```

通过这段代码，我更深入理解了Python中的模块导入、变量、条件语句、循环和数学运算的应用。
它不仅是数学计算的示例，还是如何将编程应用于实际问题解决的示范。
强调了每日微小的差异如何在长期内产生重大影响。通过不断调整工作日提升值，我们可以达到每天提升1%的效果，也使我对编程的应用和逻辑推理有了更深入的认识。
