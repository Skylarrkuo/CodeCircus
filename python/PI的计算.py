'''
算法名称: 掷点数求解Π的算法
输入: 无
输出: Π的值

开始算法:
1. 初始化变量n和a为0.0，用来记录圆内点数和总点数
2. 循环执行以下步骤100000次:
2.1 生成两个随机数x和y
2.2 计算点(x, y)到原点的距离r，使用勾股定理
2.3 如果r小于等于1.0，则圆内点数n加1
2.4 总点数a加1
3. 计算Π的值，使用公式PI = 4 * (n / a)
4. 输出Π的值
5. 输出运行时间
'''
#Π的计算
import time
time.process_time()
'''
#BBP公式求解法
PI=0.0
for k in range(0,10000):
    PI+=(1/(16**k))*((4/(8*k+1)) - (2/(8*k+4)) - (1/(8*k+5)) - (1/(8*k+6)))
'''
#掷点数求解法
import random
import math
n=a=0.0
#random.seed(9999)  #定义一个随机种子使生成结果一致
for i in range(1,100000):
    x=random.random()
    y=random.random()
    r=math.sqrt(math.pow(x,2)+math.pow(y,2))
    if(r<=1.0):
        n=n+1.0#圆内点数++
    a=a+1.0#总点数++
PI=4*(n/a)

print("Π的值是：{:.10f}".format(PI))
print("运行时间是{:.5}s".format(time.process_time()))

'''
通过生成随机点的方法，利用圆的面积与正方形的面积的比例来近似计算Π的值。
也通过time库进行了计时，可以看到随着点数的增加，计算Π的精度会提高，
但同时运行时间也会增加。
学到了一种有效的近似计算Π的方法，同时提醒了考虑运行时间的重要性。
'''